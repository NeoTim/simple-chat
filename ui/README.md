# Swim Chat UI

Like with the server side of this example, the UI is done as simply and straight forward as possible. All the main logic is done inside of /ui/assets/js/chat.js. Everything is done using vanilla javascript with the only dependency being the Swim Client Library. Likewise the CSS and HTML is all simple and vanilla as possible.

One the chat page itself there are four main sections. There is a rooms list in the left sidebar which shows all rooms available on the server. Under the rooms list is a list of users who are current in the room the user has selected (public by default). In the main content area we have the chat message list and under that is the message input field. Selecting different rooms in the Rooms list will leave the current room and join the selected room.

On page load, Chat.js will open several links to the Swim Server in order to load up the all the data for chat on that server. The first link that is opened is a map lane to the `Rooms` WebAgent and is saved to the `roomListLink` member variable inside the Chat class. When a room is created or removed on the server, the didUpdate and didRemove callback handlers will be called to handle the change. Both methods will update the array of rooms held in the roomsList member variable and then call renderRoomList() which will flush the existing list from the UI and re-render the list based on what is in the roomsList member variable. In the real world it would be better to maintain DOM elements along with the roomsList array so that flushing and re-rendering the full list would not be necessary but for simplicity we are doing a full flush and rebuild.

When the UI is rendering the rooms list, it uses the data it received from the roomList array to create a new link to the WebAgent for *each* room on the server in order to get the number of users in that room. This way the UI can show the user count for every room without actually being in that room. This link does not affect the user count for the room and so users will not appear until they connect to the MessageList map lane for the room.

Once the rooms list is rendered, the next thing is to link to the messageList map lane in order to get the chat messages and users in the room. This is handled by the `setActiveRoom` method in chat.js which is called both on page load to put the user into the default public room, and its called when a user selects a new room from the rooms list. The messages are pulled from a map lane inside the Room WebAgent called just 'messageList'. The link itself is stored in the messageListLink member variable and it has 2 callback handler. One for when new messages are added and a second for when existing messages are removed. Like the rooms list, both callback handlers update the messageList array and then call renderMessageList() to flush and redraw the messages based on the updated array.

The `setActiveRoom` method also creates a link to the `users` lane of the room to get a listing of all the users who are currently in the room. User tracking is done automatically on the server when a user connects and disconnects to the messageList lane for each WebAgent. For more information about how this works, see the README under /server in this project. There are also callback handlers setup to listen for when the users either is disconnecting or is about to re-sync. This is necessary to handle when the user's websocket times out and reconnects due to inactivity and these methods make sure the UI stays in the correct state without duplicate or stale data during a reconnection.

When a user posts a new chat message, that gets sent as a string representation of a JSON object to the `postMessage` command lane in the swim server. This JSON object is created by the postMessage() event handler in chat.js and uses the value in the message input field and the user's local IP to create the JSON data sent to the server. We are passing strings instead of objects to avoid any data type conversion issues and ensure that no matter what the user enters it get sent in a safe manner to the server. All user input is render back on the page using the innerText of the parent DOM element instead of innerHTML in order to prevent users from entering malicious javascript or html which could break the page or create a security issue. In the real would it best to also include validation of the user input on both the client and the server just to be 100% sure the user cant be malicious.

The render methods for the page are all just vanilla DOM calls and are always based on member variable arrays inside the class. This ensures that, if needed, we can update the data out of sync with updating the UI. In the real world this is important as itâ€™s possible to get updates from the Swim server faster then the browser can redraw which in turn can create a performance bottleneck in the browser. However, for simplicity in this example we update the data and UI in the same method. This could be easily changed by moving the render() calls into an OnAnimationFrame callback handler with a dirty flag so that the UI only gets updated when the browser is ready and the data has changed.

The last thing in chat.js is a snippet of code which uses RTPCPeerConnects to find the user's local IP. We need this IP because it ends up used as the user name in the Users list.




